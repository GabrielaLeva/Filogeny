### NOTE: nearly this entire file was generated by Github copilot (GPT5-mini)
### NOTE: Node class and most of the methods in PhyloTree  class were chcked by Gabriela Lewandowska
### NOTE: Subesquent refactors in TreeAlgs.py and Visualiser.py were done manually
### NOTE: to_netwick hasn't been checked at all. use at your own riak
class Node:
    def __init__(self, name, height=0.0,leaves=1):
        self.name = name
        self.height = float(height)    # distance from this node down to leaves
        self.children = []            # list of (Node, branch_length)
        self.leaves = leaves
        self.parent = None

    def add_child(self, child_node, branch_length):
        self.children.append((child_node, float(branch_length)))
        child_node.parent = self

class PhyloTree:
    def __init__(self, taxa_labels=[]):
        self._all_nodes = []          # keep every node created (for serialization/traversal)
        self.nodes = {}               # current clusters mapping name -> Node
        self.working_labels=taxa_labels    # for tree construction readability
        self.root = None
        if taxa_labels:
            for label in taxa_labels:
                n = Node(label)
                self._all_nodes.append(n)
                self.nodes[label] = n

    def add_cluster(self, new_label, left_label, right_label, left_dist, right_dist):
        """
        Create a new internal node named new_label at given height.
        left_label and right_label must refer to existing nodes in self.nodes.
        Branch lengths to children are computed as height - child.height.
        """
        self.working_labels.insert(0,new_label)
        self.working_labels.remove(left_label)
        self.working_labels.remove(right_label)
        left = self.nodes.pop(left_label)
        right = self.nodes.pop(right_label)
        h=max(left_dist+left.height,left_dist+left.height)
        l=left.leaves+right.leaves
        new_node = Node(new_label, height=h,leaves=l)
        new_node.add_child(left, left_dist)
        new_node.add_child(right, right_dist)
        self._all_nodes.append(new_node)
        self.nodes[new_label] = new_node
        self.root = new_node

    def get_height(self, label):
        return self.nodes[label].height

    def to_dict(self):
        """
        Convert internal tree to similar dict structure used previously:
        { "ClusterName": { "childA": branch_len, "childB": branch_len}, ... }
        Traverses from the root and outputs internal nodes only.
        """
        if not self.root:
            return {}
        out = {}
        def walk(node):
            if not node.children:
                return
            entry = {}
            for child, bl in node.children:
                entry[child.name] = bl
            out[node.name] = entry
            for child, _ in node.children:
                walk(child)
        walk(self.root)
        return out
    
    def to_netwick(self, include_internal=False, precision=6):
        """
        Return a Newick-like string for the tree (ends with ';').
        - include_internal: if True, include internal node names after ')'
        - precision: number of decimal places for branch lengths (trailing zeros trimmed)
        Example: tree.to_netwick() -> "(A:0.1,B:0.2)root;"
        """
        if not self.root:
            return ';'
        def fmt(x):
            s = f"{x:.{precision}f}"
            # trim trailing zeros and optional trailing dot
            s = s.rstrip('0').rstrip('.')
            return s if s != '' else '0'
        def walk(node):
            if not node.children:
                return node.name
            parts = []
            for child, bl in node.children:
                child_str = walk(child)
                parts.append(f"{child_str}:{fmt(bl)}")
            inner = ",".join(parts)
            name = node.name if include_internal else ""
            return f"({inner}){name}"
        return walk(self.root) + ';'

    def __repr__(self):
        return f"<PhyloTree root={self.root.name if self.root else None}>"